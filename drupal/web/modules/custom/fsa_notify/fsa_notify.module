<?php

/**
 * @file
 * Contains fsa_notify.module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\fsa_notify\FsaNotifyAPIemail;
use Drupal\fsa_notify\FsaNotifyAPIsms;
use Drupal\fsa_notify\FsaNotifyMessageDaily;
use Drupal\fsa_notify\FsaNotifyMessageImmediate;
use Drupal\fsa_notify\FsaNotifyMessageSms;
use Drupal\fsa_notify\FsaNotifyMessageWeekly;
use Drupal\fsa_notify\FsaNotifyStorage;
use Drupal\fsa_notify\Plugin\QueueWorker\FsaNotifyStorageQueue;
use Drupal\node\NodeInterface;
use Drupal\user\Entity\User;
use Drupal\Component\Datetime\Time;

/**
 * Implements hook_form_user_form_alter().
 */
function fsa_notify_form_user_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['field_notification_sms']['#element_validate'][] = 'fsa_notify_validate';
}

/**
 * Data integrity: require phone number if user chooses sms method.
 */
function fsa_notify_validate(&$form, FormStateInterface $form_state) {

  $field = 'field_notification_method';
  $method = $form_state->getValue($field);
  if (empty($method[0]['value']) || $method[0]['value'] != 'sms') {
    return;
  }

  $field = 'field_notification_sms';
  $sms = $form_state->getValue($field);
  if (!empty($sms[0]['value'])) {
    return;
  }

  $form_state->setErrorByName($field, t('If "Notification method" is SMS then "Notification SMS" is required.'));
}

/**
 * Collect inserted alerts.
 */
function fsa_notify_entity_insert(EntityInterface $entity) {

  // Define content types that may be sent via Notify.
  $types_to_send = ['alert', 'news', 'consultation'];

  if (!($entity instanceof NodeInterface)) {
    return;
  }
  if (!in_array($entity->getType(), $types_to_send)) {
    return;
  }

  $queue = \Drupal::service('queue')->get('fsa_notify_store');
  $data = $entity->id();
  $queue->createItem($data);
}

function fsa_notify_node_presave(NodeInterface $node) {

  // Define content types that may be sent via Notify.
  $types_to_send = ['news', 'consultation'];
  if (!in_array($node->getType(), $types_to_send)) {
    return;
  }

  if ($node->hasField('field_alert_send')) {
    if ($node->field_alert_send->value) {
      // Stamp the node sent date field with current time. Informational only.
      $node->field_alert_send_timestamp[] = date('Y-m-d\TH:i:s', \Drupal::service('datetime.time')->getCurrentTime());

      // Let user know the alert was queued.
      drupal_set_message(t('This @type item was queued to be sent as alert for all subscribers', ['@type' => $node->getType()]), 'warning');
    }
  }

  // And unset the alert sending checkbox.
  $node->field_alert_send = 0;
}

/**
 * Implements hook_form_alter().
 */
function fsa_notify_form_alter(&$form, FormStateInterface $form_state, $form_id) {

  $forms = [
    'node_news_edit_form',
    'node_consultation_edit_form',
  ];
  if (in_array($form_id, $forms)) {
    $form['field_alert_send_timestamp']['widget']['add_more']['#access'] = FALSE;
    $form['field_alert_send_timestamp']['#disabled'] = 'disabled';
  }
}

/**
 * Notify cron job.
 *
 * Keep all stuff as abstract as possible here so that it would be easy to
 * understand highlevel workflow just major decisions and major tasks.
 */
function fsa_notify_cron() {

  $state_key = 'fsa_notify.killswitch';
  $killswitch = \Drupal::state()->get($state_key);
  if (empty($killswitch)) {
    return;
  }

  // Process alerts
  // (insert it into each user cache who wants to be notified)
  fsa_notify_queue_process();

  /* now start sending */

  // Prepare.
  $notifier_sms = new FsaNotifyAPIsms();
  $notifier_email = new FsaNotifyAPIemail();
  $storage = new FsaNotifyStorage();

  // Sms.
  $formatter = new FsaNotifyMessageSms();
  fsa_notify_send($storage, $notifier_sms, $formatter, 'sms');

  // Immediate.
  $formatter = new FsaNotifyMessageImmediate();
  fsa_notify_send($storage, $notifier_email, $formatter, 'immediate');

  // Daily.
  $state_key = 'fsa_notify.last_daily';
  $formatter = new FsaNotifyMessageDaily();
  if (fsa_notify_daily_is_ready_to_send($state_key)) {
    fsa_notify_send($storage, $notifier_email, $formatter, 'daily');
    fsa_notify_sent($state_key);
  }

  // Weekly.
  $state_key = 'fsa_notify.last_weekly';
  $formatter = new FsaNotifyMessageWeekly();
  if (fsa_notify_weekly_is_ready_to_send($state_key)) {
    fsa_notify_send($storage, $notifier_email, $formatter, 'weekly');
    fsa_notify_sent($state_key);
  }
}

/**
 * Store the last sent status.
 *
 * @param string $state_key
 *   The state key to set (fsa_notify.last_daily|fsa_notify.last_weekly).
 */
function fsa_notify_sent($state_key) {
  $now = time();
  $last = \Drupal::state()->set($state_key, $now);
}

/**
 * Check if daily digests are ready to be sent.
 *
 * @param string $state_key
 *   The state key (fsa_notify.last_daily|fsa_notify.last_weekly)
 * @param int $now
 *   Timestamp for testing purposes.
 *
 * @return bool
 *   Boolean if daily digests are ready to send.
 */
function fsa_notify_daily_is_ready_to_send($state_key, $now = NULL) {
  // $now argument is used only for algorithm testing purposes.
  if (empty($now)) {
    $now = time();
  }
  $window = 3 * 60 * 60;
  $interval = 24 * 60 * 60;
  // Calculation base: seconds since 00:00:00.
  $start = 7 * 60 * 60;
  $current = date('G', $now) * 60 * 60 + date('i', $now) * 60 + date('s', $now);
  $ready = fsa_notify_is_ready_to_send($state_key, $window, $interval, $start, $current, $now);
  return $ready;
}

/**
 * Check if weekly digests are ready to send.
 *
 * @param string $state_key
 *   The state key (fsa_notify.last_daily|fsa_notify.last_weekly)
 * @param int $now
 *   Timestamp for testing purposes.
 *
 * @return bool
 *   Boolean if weekly digests are ready to send.
 */
function fsa_notify_weekly_is_ready_to_send($state_key, $now = NULL) {
  // $now argument is used only for algorithm testing purposes.
  if (empty($now)) {
    $now = time();
  }
  $window = 5 * 60 * 60;
  $interval = 7 * 24 * 60 * 60;
  // Calculation base: 1 (for Monday) through 7 (for Sunday)
  $start = 1 * 24 * 60 * 60 + 7 * 60 * 60;
  $current = date('N', $now) * 24 * 60 * 60 + date('G', $now) * 60 * 60 + date('i', $now) * 60 + date('s', $now);
  $ready = fsa_notify_is_ready_to_send($state_key, $window, $interval, $start, $current, $now);
  return $ready;
}

/**
 * Check if batch is ready for notify to send.
 *
 * @param string $state_key
 *   Drupal state to get/set related info.
 * @param int $window
 *   Duration window for sending out emails.
 * @param int $interval
 *   Duration between beginnings of two sendings.
 * @param int $start
 *   Arbitrary start timestamp, in context of interval.
 * @param int $current
 *   Arbitrary current timestamp, in context of interval.
 * @param null|int $now
 *   Now argument is used only for algorithm testing purposes.
 *
 * @return bool
 *   Boolean if ready to send.
 */
function fsa_notify_is_ready_to_send($state_key, $window, $interval, $start, $current, $now = NULL) {
  if (empty($now)) {
    $now = time();
  }

  $last = \Drupal::state()->get($state_key);
  if (empty($last)) {
    fsa_notify_sent($state_key);
    return TRUE;
  }

  // Is elapsed enough time since last time.
  $is_elapsed_enough = $now - $last;
  // So that we wont send out emails each time later and later.
  $is_elapsed_enough = $is_elapsed_enough > $interval - $window;

  $is_in_window = $start <= $current && $current < $start + $window;

  return $is_elapsed_enough && $is_in_window;
}

/**
 * Process queued alerts.
 */
function fsa_notify_queue_process() {

  $queue = Drupal::service('queue')->get('fsa_notify_store');
  $worker = Drupal::service('plugin.manager.queue_worker')->createInstance('fsa_notify_store');

  fsa_notify_timer('start', 'queue');

  while ($item = $queue->claimItem()) {
    try {
      $worker->processItem($item->data);
      $queue->deleteItem($item);
    }
    catch (FsaNotifyStorageQueue $e) {
      $queue->releaseItem($item);
      break;
    }
    catch (\Exception $e) {
      watchdog_exception('fsa_notify', $e);
    }
    fsa_notify_timer('count', 'queue');
  }

  fsa_notify_timer('stop', 'queue');

}

/**
 * Send to notify.
 *
 * @param \Drupal\fsa_notify\FsaNotifyStorage $storage
 *   FsaNotifyStorage object.
 * @param object $notifier
 *   Notifier object.
 * @param object $formatter
 *   Notifymessage formatter object.
 * @param string $type
 *   Type of send (SMS/immediate/digest).
 */
function fsa_notify_send(FsaNotifyStorage $storage, $notifier, $formatter, $type) {
  fsa_notify_timer('start', $type);
  while ($batch = $storage->getAllType($type)) {
    foreach ($batch as $uid => $messages) {
      $user = User::load($uid);
      $messages = $formatter->format($messages);
      foreach ($messages as $personalisation) {
        $notifier->send($user, $type, $personalisation);
        fsa_notify_timer('count', $type);
      }
      $storage->reset($user);
    }
    \Drupal::entityManager()->getStorage('node')->resetCache();
    \Drupal::entityManager()->getStorage('user')->resetCache();
  }
  fsa_notify_timer('stop', $type);
}

/**
 * The timer for notify process.
 *
 * @param string $event
 *   Type of the event (start|count|stop).
 * @param string $type
 *   The type (SMS/immediate/digest).
 */
function fsa_notify_timer($event, $type) {

  static $cache = [];

  switch ($event) {

    case 'start':
      $cache[$type] = [
        'start' => microtime(TRUE),
        'count' => 0,
      ];
      break;

    case 'count':
      $cache[$type]['count']++;
      break;

    case 'stop':
      $stop = microtime(TRUE);
      $start = $cache[$type]['start'];
      $items = $cache[$type]['count'];
      unset($cache[$type]);
      if ($items == 0) {
        // Dont fill logs with zeros.
        break;
      }
      $elapsed = $stop - $start;
      $rate = $elapsed > 0 ? $items / $elapsed : 'n/a';
      $elapsed = sprintf('%.3f', $elapsed);
      $rate = sprintf('%.3f', $rate);
      \Drupal::logger('fsa_notify')->info('Timer: type %type; elapsed %elapsed; %items items; %rate items/sec.', [
        '%type' => $type,
        '%elapsed' => $elapsed,
        '%items' => $items,
        '%rate' => $rate,
      ]);
      break;
  }

}
